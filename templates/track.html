{% extends "base.html" %}

{% block content %}
<div class="container mt-4">
    <div class="main-card wide-card">
        <div class="d-flex justify-content-between align-items-center mb-3">
            <h2>{{ track_name }} Sessions</h2>
            <a href="{{ url_for('download', track_name=track_name) }}" class="btn btn-primary">
                Download CSV
            </a>
        </div>

        <!-- Chart & Table Row -->
        <div class="row mt-3 g-3">
          <div class="col-lg-6 col-xl-5">
            <!-- Chart Section -->
            <div class="d-flex flex-wrap justify-content-between align-items-center gap-2">
                <div>
                    <label for="timeFilter" class="form-label me-2">Session View:</label>
                    <select id="timeFilter" class="form-select form-select-sm d-inline w-auto">
                        <option value="improvement">Personal Bests Only</option>
                        <option value="all" selected>Every Race</option>
                        <option value="monthly">Fastest Race Each Month</option>
                        <option value="weekly">Fastest Race Each Week</option>
                        <option value="daily">Fastest Race Each Day</option>
                    </select>
                </div>
                <div>
                    <label for="rangeFilter" class="form-label me-2">Time Range:</label>
                    <select id="rangeFilter" class="form-select form-select-sm d-inline w-auto">
                        <option value="all" selected>All Time</option>
                        <option value="this_week">This Week</option>
                        <option value="this_month">This Month</option>
                        <option value="this_year">This Year</option>
                        <option value="custom">Custom Range</option>
                    </select>
                </div>
                <div id="customRangeInputs" style="display:none;">
                    <label for="fromDate" class="form-label me-1">From:</label>
                    <input type="date" id="fromDate" class="form-control form-control-sm d-inline w-auto me-2" placeholder="mm/dd/yyyy">
                    <label for="toDate" class="form-label me-1">To:</label>
                    <input type="date" id="toDate" class="form-control form-control-sm d-inline w-auto" placeholder="mm/dd/yyyy">
                </div>
                <div>
                    <label for="driftFilter" class="form-label me-2">Drift Nights:</label>
                    <select id="driftFilter" class="form-select form-select-sm d-inline w-auto">
                        <option value="all" selected>Show All</option>
                        <option value="hide">Hide Drift Nights</option>
                        <option value="hide_after">Hide Drift + After</option>
                        <option value="only">Only Drift Nights</option>
                        <option value="only_after">Drift Nights + After</option>
                    </select>
                </div>
            </div>

            <!-- Updated Chart Container -->
            <div class="chart-container-ios mt-3">
                <div style="position: relative; width: 100%; height: 400px;">
                    <canvas id="progressChart" style="touch-action: none; width: 100%; height: 100%;"></canvas>
                </div>
            </div>
            <div class="d-flex justify-content-between align-items-center mt-1">
                <small class="text-muted"><em>Zoom may not work on all mobile browsers. Try desktop.</em></small>
                <button id="resetZoom" class="btn btn-outline-secondary btn-sm ms-2 chart-btn">Reset Zoom</button>
            </div>
            <div id="driftInfo" class="text-muted small"></div>
            <div id="driftAfterDiv" class="small mt-1" style="display:none;">
                Include sessions within
                <input type="number" id="driftDays" value="1" min="0" class="form-control form-control-sm d-inline w-auto ms-1 me-1">days after drift nights
                <button id="applyDriftFilter" class="btn btn-outline-secondary btn-sm chart-btn">Apply</button>
            </div>
          </div>

          <!-- Session Table Section -->
          <div class="col-lg-6 col-xl-7">
            <div class="table-container-ios mt-4 mt-lg-0">
                <div class="small text-muted mb-1">Click any column header to sort the table. Click any session date to view session details.</div>
                <table id="lapsTable" class="table table-striped">
                <thead>
                    <tr>
                        <th class="sortable-header"><button type="button" class="btn btn-light btn-sm sort-button w-100" onclick="sortTable(0)">Date <span class="sort-icons">⇅</span></button></th>
                        <th class="sortable-header"><button type="button" class="btn btn-light btn-sm sort-button w-100" onclick="sortTable(1)">Best Lap <span class="sort-icons">⇅</span></button></th>
                        <th class="sortable-header"><button type="button" class="btn btn-light btn-sm sort-button w-100" onclick="sortTable(2)">Avg Lap <span class="sort-icons">⇅</span></button></th>
                        <th class="sortable-header"><button type="button" class="btn btn-light btn-sm sort-button w-100" onclick="sortTable(3)">Kart # <span class="sort-icons">⇅</span></button></th>
                        <th class="sortable-header"><button type="button" class="btn btn-light btn-sm sort-button w-100" onclick="sortTable(4)">Total Laps <span class="sort-icons">⇅</span></button></th>
                        <th class="sortable-header"><button type="button" class="btn btn-light btn-sm sort-button w-100" onclick="sortTable(5)">Fastest Lap # <span class="sort-icons">⇅</span></button></th>
                        {% for i in range(1, 17) %}
                        <th class="sortable-header"><button type="button" class="btn btn-light btn-sm sort-button w-100" onclick="sortTable({{ i + 5 }})">Lap {{ i }} <span class="sort-icons">⇅</span></button></th>
                        {% endfor %}
                    </tr>
                </thead>
                <tbody>
                    {% for s in sessions %}
                    <tr class="{% if s.challenge_gp %}table-success challenge-gp{% elif s.drift_night %}table-warning drift-night{% endif %}"
                        data-challenge="{{ 'true' if s.challenge_gp else 'false' }}"
                        data-drift="{{ 'true' if s.drift_night else 'false' }}"
                        data-datetime="{{ s.date_iso }}"
                        data-session="{{ s.id }}">
                        <td data-sort="{{ s.date_iso }}"><a href="{{ url_for('race_detail', session_id=s.id) }}">{{ s.date_display }}</a></td>
                        <td>{{ s.best_lap }}</td>
                        <td>{{ s.avg_lap }}</td>
                        <td>
                          <div class="kart-entry">
                            <input type="text" class="form-control form-control-sm kart-input" placeholder="Kart #">
                            <button type="button" class="btn btn-secondary btn-sm kart-save-btn">Save</button>
                          </div>
                        </td>
                        <td>{{ s.total_laps }}</td>
                        <td>{{ s.fastest_lap_num }}</td>
                        {% for lap in s.laps %}
                        <td>{{ "%.3f"|format(lap|float) }}</td>
                        {% endfor %}
                        {% for i in range(16 - s.laps|length) %}
                        <td></td>
                        {% endfor %}
                    </tr>
                    {% endfor %}
                </tbody>
            </table>
            </div>
            <div class="text-start mb-2">
              <button id="toggleRows" class="btn btn-outline-secondary btn-sm chart-btn">Show All</button>
              <button id="challengeBtn" class="btn btn-outline-secondary btn-sm chart-btn ms-2">Show Potential Challenge GP</button>
              <button id="driftBtn" class="btn btn-outline-secondary btn-sm chart-btn ms-2">Show Drift Nights</button>
            </div>
            <div class="alert alert-info small py-2 px-3">
              <strong>Legend:</strong>
              <ul class="mb-0 ps-3">
                <li><span class="badge bg-success me-1">Green rows</span> mark sessions that match the Challenge GP heuristic (14+ laps, run during the first week of a month on Sunday or Monday). Detection is date and lap count based, so races with laps added or deleted could get detected incorrectly.</li>
                <li><span class="badge bg-warning text-dark me-1">Yellow rows</span> highlight sessions where your best lap was slower than the median pace + 7 seconds, which usually indicates a drift night.</li>
                <li>Use the Drift Nights controls to quickly focus on or hide these sessions in both the chart and the table.</li>
              </ul>
            </div>
          </div>
        </div>
    </div>
</div>

<style>
.chart-container-ios {
    background-color: #fff;
    padding: 10px;
    border-radius: 8px;
    overflow: hidden;
    -webkit-overflow-scrolling: touch;
    width: 100%;
    touch-action: none;
}

#progressChart {
    max-width: 100%;
    height: 100%;
    max-height: none;
    touch-action: none;
}

/* Table styles (unchanged) */
.table-container-ios {
    overflow: auto;
    -webkit-overflow-scrolling: touch;
    width: 100%;
    border-radius: 8px;
    margin-bottom: 1rem;
    max-height: 400px;
}
.table-container-ios table {
    min-width: 600px;
}
.table-container-ios tbody tr {
    height: 50px;
}
.table-container-ios::-webkit-scrollbar {
    -webkit-appearance: none;
    height: 5px;
}
.table-container-ios::-webkit-scrollbar-thumb {
    border-radius: 4px;
    background-color: rgba(0,0,0,.2);
}

/* Style for sortable table headers */
#lapsTable th.sortable-header {
    background-color: #f8f9fa;
    user-select: none;
}

#lapsTable th.sortable-header:hover {
    background-color: #e2e6ea;
}

.sort-button {
    width: 100%;
}

.challenge-gp {
    font-weight: 600;
}

.drift-night {
    font-weight: 600;
}

.kart-input {
    min-width: 80px;
}

.kart-entry {
    display: flex;
    align-items: center;
    gap: 0.5rem;
}

.kart-entry .kart-save-btn {
    white-space: nowrap;
}

.chart-btn,
.sort-button {
    background-color: #e74c3c;
    border: 1px solid #000;
    color: #fff;
}

.chart-btn:hover,
.sort-button:hover {
    background-color: #c0392b;
}
</style>

<script>
document.addEventListener("DOMContentLoaded", function () {
    const labels = {{ chart_data.dates | tojson }};
    const times = {{ chart_data.date_times | tojson }};
    const data = {{ chart_data.best_laps | tojson }};
    const driftCutoff = {{ chart_data.drift_cutoff | tojson }};

    const ctx = document.getElementById('progressChart');
    const driftFilterSelect = document.getElementById('driftFilter');
    const driftDaysInput = document.getElementById('driftDays');
    const driftInfo = document.getElementById('driftInfo');
    const driftAfterDiv = document.getElementById('driftAfterDiv');
    const applyBtn = document.getElementById('applyDriftFilter');
    const resetZoomBtn = document.getElementById('resetZoom');

    const table = document.getElementById('lapsTable');
    const tableContainer = document.querySelector('.table-container-ios');
    const btnToggle = document.getElementById('toggleRows');
    const challengeBtn = document.getElementById('challengeBtn');
    const driftBtn = document.getElementById('driftBtn');

    const MAX_ROWS = 10;
    const driftFlags = data.map(v => driftCutoff ? v >= driftCutoff : false);
    let filteredLabels = labels.slice();
    let filteredData = data.slice();
    let filteredTimes = times.slice();
    let showAllRows = false;
    let challengeOnly = false;
    let sortDirections = [];
    let savedDriftMode = driftFilterSelect ? driftFilterSelect.value : 'all';
    let driftBtnActive = false;

    const KART_STORAGE_KEY = 'kartAssignments';

    function loadKartAssignments() {
        try {
            const stored = localStorage.getItem(KART_STORAGE_KEY);
            return stored ? JSON.parse(stored) : {};
        } catch (err) {
            console.warn('Unable to read kart assignments from storage.', err);
            return {};
        }
    }

    let kartAssignments = loadKartAssignments();

    function saveKartAssignments() {
        try {
            localStorage.setItem(KART_STORAGE_KEY, JSON.stringify(kartAssignments));
        } catch (err) {
            console.warn('Unable to save kart assignments.', err);
        }
    }

    function refreshKartInputs() {
        if (!table || !table.tBodies.length) return;
        const rows = Array.from(table.tBodies[0].rows);
        rows.forEach(row => {
            const sessionId = row.dataset.session;
            if (!sessionId) return;
            const input = row.querySelector('.kart-input');
            if (!input) return;
            const storedValue = kartAssignments[sessionId] || '';
            if (input.value !== storedValue) {
                input.value = storedValue;
            }
        });
    }

    function broadcastKartUpdate(sessionId, value) {
        const event = new CustomEvent('kartAssignmentUpdated', {
            detail: { sessionId, value }
        });
        window.dispatchEvent(event);
    }

    function persistKartAssignment(sessionId, value) {
        const trimmedValue = value.trim();
        if (trimmedValue) {
            kartAssignments[sessionId] = trimmedValue;
        } else {
            delete kartAssignments[sessionId];
        }
        saveKartAssignments();
        refreshKartInputs();
        broadcastKartUpdate(sessionId, trimmedValue);
    }

    if (table && table.tBodies.length) {
        const rows = Array.from(table.tBodies[0].rows);
        rows.forEach(row => {
            const sessionId = row.dataset.session;
            if (!sessionId) return;
            const input = row.querySelector('.kart-input');
            if (!input) return;
            const saveButton = row.querySelector('.kart-save-btn');
            const storedValue = kartAssignments[sessionId];
            if (storedValue) {
                input.value = storedValue;
            }
            if (saveButton) {
                saveButton.addEventListener('click', () => {
                    persistKartAssignment(sessionId, input.value);
                });
            }
            input.addEventListener('keydown', (event) => {
                if (event.key === 'Enter') {
                    event.preventDefault();
                    persistKartAssignment(sessionId, input.value);
                }
            });
        });
    }

    window.addEventListener('storage', (event) => {
        if (event.key !== KART_STORAGE_KEY) return;
        kartAssignments = loadKartAssignments();
        refreshKartInputs();
    });

    window.addEventListener('kartAssignmentUpdated', (event) => {
        if (!event.detail || !event.detail.sessionId) return;
        const { sessionId, value } = event.detail;
        if (value) {
            kartAssignments[sessionId] = value;
        } else {
            delete kartAssignments[sessionId];
        }
        refreshKartInputs();
    });

    refreshKartInputs();

    function updateDriftButtonState() {
        if (!driftBtn || !driftFilterSelect) return;
        const currentValue = driftFilterSelect.value;
        driftBtnActive = currentValue === 'only';
        if (!driftBtnActive) {
            savedDriftMode = currentValue;
        }
        driftBtn.textContent = driftBtnActive ? 'Show All Sessions' : 'Show Drift Nights';
        driftBtn.dataset.filtered = driftBtnActive ? 'true' : 'false';
    }

    function getWeek(dateStr) {
        const [y, m, d] = dateStr.split('-').map(Number);
        const dt = new Date(Date.UTC(y, m - 1, d));
        dt.setUTCDate(dt.getUTCDate() + 4 - (dt.getUTCDay() || 7));
        const yearStart = new Date(Date.UTC(dt.getUTCFullYear(), 0, 1));
        return Math.ceil((((dt - yearStart) / 86400000) + 1) / 7);
    }

    function getAfterRanges(afterDays) {
        const ranges = [];
        if (afterDays <= 0) {
            return ranges;
        }
        driftFlags.forEach((flag, idx) => {
            if (!flag) return;
            const base = new Date(times[idx]);
            if (Number.isNaN(base.getTime())) return;
            const start = new Date(base);
            start.setHours(16, 0, 0, 0);
            const end = new Date(start);
            end.setDate(end.getDate() + afterDays - 1);
            end.setHours(23, 59, 59, 999);
            ranges.push({ start, end });
        });
        return ranges;
    }

    function isWithinRanges(date, ranges) {
        if (!date || !ranges.length) return false;
        return ranges.some(range => date >= range.start && date <= range.end);
    }

    function shouldInclude(mode, isDrift, isAfter) {
        if (mode === 'hide') return !isDrift;
        if (mode === 'hide_after') {
            if (isDrift) return false;
            if (isAfter) return false;
            return true;
        }
        if (mode === 'only') return isDrift;
        if (mode === 'only_after') return isDrift || isAfter;
        return true;
    }

    function getCellValue(row, colIndex) {
        const cell = row.cells[colIndex];
        if (!cell) return '';
        const input = cell.querySelector('input');
        if (input) return input.value.trim();
        if (cell.dataset && cell.dataset.sort) return cell.dataset.sort;
        return cell.innerText.trim();
    }

    function applyRowPaging() {
        if (!table || !tableContainer || !btnToggle) return;
        const visibleRows = Array.from(table.tBodies[0].rows).filter(row => row.style.display !== 'none');
        if (visibleRows.length <= MAX_ROWS) {
            visibleRows.forEach(row => row.classList.remove('d-none'));
            tableContainer.style.maxHeight = '400px';
            btnToggle.style.display = 'none';
            showAllRows = false;
            return;
        }
        btnToggle.style.display = '';
        if (showAllRows) {
            visibleRows.forEach(row => row.classList.remove('d-none'));
            tableContainer.style.maxHeight = '80vh';
            btnToggle.textContent = 'Show Less';
        } else {
            visibleRows.forEach((row, index) => {
                if (index >= MAX_ROWS) row.classList.add('d-none');
                else row.classList.remove('d-none');
            });
            tableContainer.style.maxHeight = '400px';
            btnToggle.textContent = 'Show All';
        }
    }

    function applyTableFilters() {
        if (!table) return;
    const mode = driftFilterSelect ? driftFilterSelect.value : 'all';
    const afterDaysValue = driftDaysInput ? (parseInt(driftDaysInput.value, 10) || 0) : 0;
        const includeAfter = (mode === 'hide_after' || mode === 'only_after') && afterDaysValue > 0;
        const afterRanges = includeAfter ? getAfterRanges(afterDaysValue) : [];
        const rows = Array.from(table.tBodies[0].rows);
        rows.forEach(row => {
            row.classList.remove('d-none');
            const isChallenge = row.dataset.challenge === 'true';
            const isDrift = row.dataset.drift === 'true';
            const dateIso = row.dataset.datetime;
            const rowDate = dateIso ? new Date(dateIso) : null;
            const isAfter = includeAfter && rowDate ? isWithinRanges(rowDate, afterRanges) : false;
            let visible = shouldInclude(mode, isDrift, isAfter);
            if (challengeOnly && !isChallenge) {
                visible = false;
            }
            row.style.display = visible ? '' : 'none';
        });
        applyRowPaging();
    }

    function filterByTimeRange(range) {
        const now = new Date();
        let fromDate = null;

        if (range === 'this_month') {
            fromDate = new Date(now.getFullYear(), now.getMonth(), 1);
        } else if (range === 'this_week') {
            const day = now.getDay() || 7;
            fromDate = new Date(now);
            fromDate.setDate(now.getDate() - day + 1);
        } else if (range === 'this_year') {
            fromDate = new Date(now.getFullYear(), 0, 1);
        } else if (range === 'custom') {
            const from = document.getElementById('fromDate').value;
            const to = document.getElementById('toDate').value;
            if (from && to) {
                fromDate = new Date(from);
                const toDate = new Date(to);
                return labels.reduce((acc, dateStr, i) => {
                    const d = new Date(dateStr);
                    if (d >= fromDate && d <= toDate) {
                        acc.labels.push(dateStr);
                        acc.data.push(data[i]);
                        acc.times.push(times[i]);
                        acc.indices.push(i);
                    }
                    return acc;
                }, { labels: [], data: [], times: [], indices: [] });
            }
            return { labels: [], data: [], times: [], indices: [] };
        }

        return labels.reduce((acc, dateStr, i) => {
            const d = new Date(dateStr);
            if (!fromDate || d >= fromDate) {
                acc.labels.push(dateStr);
                acc.data.push(data[i]);
                acc.times.push(times[i]);
                acc.indices.push(i);
            }
            return acc;
        }, { labels: [], data: [], times: [], indices: [] });
    }

    let chart = null;
    if (ctx && window.Chart) {
        chart = new Chart(ctx, {
            type: 'line',
            data: {
                labels: labels,
                datasets: [{
                    label: 'Best Lap',
                    data: data,
                    borderColor: 'rgb(75, 192, 192)',
                    tension: 0.1,
                    pointBackgroundColor: 'rgb(75, 192, 192)',
                    fill: false
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                interaction: {
                    mode: 'nearest',
                    axis: 'x',
                    intersect: false
                },
                plugins: {
                    tooltip: { enabled: true },
                    legend: { display: false },
                    zoom: {
                        pan: { enabled: true, mode: 'x' },
                        zoom: {
                            wheel: { enabled: true },
                            pinch: { enabled: true },
                            mode: 'x'
                        }
                    },
                    datalabels: { display: false }
                },
                scales: {
                    y: {
                        reverse: true,
                        title: { display: true, text: 'Seconds' },
                        ticks: { color: '#000', stepSize: 0.25, maxTicksLimit: 15 }
                    },
                    x: {
                        title: { display: true, text: 'Date' },
                        ticks: { color: '#000' }
                    }
                }
            }
        });
        window.chart = chart;
    }

    function updateChart() {
        if (chart) {
            chart.resetZoom();
        }
        const viewMode = document.getElementById('timeFilter').value;
        const timeRange = document.getElementById('rangeFilter').value;
        const result = filterByTimeRange(timeRange);

        filteredLabels = result.labels;
        filteredData = result.data;
        filteredTimes = result.times;
        let indices = result.indices;

        const mode = driftFilterSelect ? driftFilterSelect.value : 'all';
        const afterDaysValue = driftDaysInput ? (parseInt(driftDaysInput.value, 10) || 0) : 0;
        const includeAfter = (mode === 'hide_after' || mode === 'only_after') && afterDaysValue > 0;
        const afterRanges = includeAfter ? getAfterRanges(afterDaysValue) : [];

        const tmpLabels = [];
        const tmpData = [];
        const tmpTimes = [];
        const tmpIndices = [];
        let removedDrift = 0;
        let removedAfter = 0;
        let shownDrift = 0;
        let shownAfter = 0;
        let totalDrift = 0;

        for (let i = 0; i < filteredLabels.length; i++) {
            const idx = indices[i];
            const isDrift = driftFlags[idx];
            const dateValue = new Date(times[idx]);
            const isAfter = includeAfter && isWithinRanges(dateValue, afterRanges);
            if (isDrift) totalDrift++;
            const include = shouldInclude(mode, isDrift, isAfter);
            if (!include) {
                if (isDrift) removedDrift++;
                else if (isAfter) removedAfter++;
                continue;
            }
            if (isDrift) shownDrift++;
            else if (isAfter) shownAfter++;
            tmpLabels.push(filteredLabels[i]);
            tmpData.push(filteredData[i]);
            tmpTimes.push(filteredTimes[i]);
            tmpIndices.push(idx);
        }

        filteredLabels = tmpLabels;
        filteredData = tmpData;
        filteredTimes = tmpTimes;
        indices = tmpIndices;

        if (chart) {
            let labelsForChart = filteredLabels;
            let dataset = filteredData;

            if (viewMode === 'improvement') {
                let impLabels = [];
                let impData = [];
                let best = Infinity;
                for (let i = 0; i < filteredLabels.length; i++) {
                    const lap = filteredData[i];
                    if (lap < best) {
                        best = lap;
                        impLabels.push(filteredLabels[i]);
                        impData.push(lap);
                    }
                }
                labelsForChart = impLabels;
                dataset = impData;
            } else if (["daily", "weekly", "monthly"].includes(viewMode)) {
                let grouped = {};
                for (let i = 0; i < filteredLabels.length; i++) {
                    let key = filteredLabels[i];
                    if (viewMode === 'monthly') key = key.slice(0, 7);
                    else if (viewMode === 'weekly') key = key.slice(0, 4) + '-W' + getWeek(key);
                    if (!(key in grouped) || grouped[key] > filteredData[i]) {
                        grouped[key] = filteredData[i];
                    }
                }
                labelsForChart = Object.keys(grouped);
                dataset = Object.values(grouped);
            }

            chart.data.labels = labelsForChart;
            chart.data.datasets[0].data = dataset;
            chart.update();
        }

        let infoText = '';
        if (!driftCutoff) {
            infoText = '';
        } else if (mode === 'hide') {
            infoText = `Filtered ${removedDrift} drift sessions.`;
        } else if (mode === 'hide_after') {
            infoText = `Filtered ${removedDrift} drift sessions.`;
            if (includeAfter) {
                infoText += ` Filtered ${removedAfter} sessions within ${afterDaysValue} day${afterDaysValue === 1 ? '' : 's'} after drift nights.`;
            }
        } else if (mode === 'only') {
            infoText = `Showing ${shownDrift} drift sessions.`;
        } else if (mode === 'only_after') {
            infoText = `Showing ${shownDrift} drift sessions.`;
            if (includeAfter) {
                infoText += ` Including ${shownAfter} additional sessions within ${afterDaysValue} day${afterDaysValue === 1 ? '' : 's'} after drift nights.`;
            }
        } else {
            infoText = `Detected ${totalDrift} likely drift sessions (threshold ${driftCutoff.toFixed(3)}s).`;
        }
        if (driftInfo) {
            driftInfo.textContent = infoText;
        }

        if (driftAfterDiv) {
            if (mode === 'hide_after' || mode === 'only_after') {
                driftAfterDiv.style.display = 'block';
            } else {
                driftAfterDiv.style.display = 'none';
            }
        }

        applyTableFilters();
    }

    const timeFilter = document.getElementById('timeFilter');
    const rangeFilter = document.getElementById('rangeFilter');
    const fromDateInput = document.getElementById('fromDate');
    const toDateInput = document.getElementById('toDate');

    if (timeFilter) timeFilter.addEventListener('change', updateChart);
    if (rangeFilter) {
        rangeFilter.addEventListener('change', function () {
            const selected = this.value;
            document.getElementById('customRangeInputs').style.display = (selected === 'custom') ? 'block' : 'none';
            updateChart();
        });
    }
    if (fromDateInput) fromDateInput.addEventListener('change', updateChart);
    if (toDateInput) toDateInput.addEventListener('change', updateChart);
    if (resetZoomBtn && chart) {
        resetZoomBtn.addEventListener('click', () => chart.resetZoom());
    } else if (resetZoomBtn) {
        resetZoomBtn.addEventListener('click', () => {});
    }

    if (driftFilterSelect) {
        driftFilterSelect.addEventListener('change', () => {
            updateDriftButtonState();
            updateChart();
        });
    }
    if (applyBtn) {
        applyBtn.addEventListener('click', () => {
            updateChart();
        });
    }

    if (driftBtn) {
        driftBtn.addEventListener('click', () => {
            if (!driftFilterSelect) return;
            if (!driftBtnActive) {
                savedDriftMode = driftFilterSelect.value === 'only' ? 'all' : driftFilterSelect.value;
                driftFilterSelect.value = 'only';
            } else {
                driftFilterSelect.value = savedDriftMode || 'all';
            }
            updateDriftButtonState();
            updateChart();
        });
    }

    if (btnToggle) {
        btnToggle.addEventListener('click', () => {
            showAllRows = !showAllRows;
            applyRowPaging();
        });
    }

    if (challengeBtn) {
        challengeBtn.addEventListener('click', () => {
            challengeOnly = !challengeOnly;
            challengeBtn.textContent = challengeOnly ? 'Show All Sessions' : 'Show Potential Challenge GP';
            challengeBtn.dataset.filtered = challengeOnly ? 'true' : 'false';
            applyTableFilters();
        });
    }

    window.sortTable = function (colIndex) {
        if (!table) return;
        const tbody = table.tBodies[0];
        const rows = Array.from(tbody.rows);
        sortDirections[colIndex] = !sortDirections[colIndex];
        const dir = sortDirections[colIndex] ? 1 : -1;

        rows.sort((a, b) => {
            if (colIndex === 0) {
                const dateA = new Date(a.dataset.datetime);
                const dateB = new Date(b.dataset.datetime);
                return (dateA - dateB) * dir;
            }
            const valueA = getCellValue(a, colIndex);
            const valueB = getCellValue(b, colIndex);
            const numA = parseFloat(valueA);
            const numB = parseFloat(valueB);
            if (!Number.isNaN(numA) && !Number.isNaN(numB)) {
                return (numA - numB) * dir;
            }
            return valueA.localeCompare(valueB) * dir;
        });

        rows.forEach(row => tbody.appendChild(row));
        applyTableFilters();
    };

    if (table && table.tBodies.length) {
        sortDirections[0] = true;
        window.sortTable(0);
    } else {
        applyTableFilters();
    }

    updateDriftButtonState();
    updateChart();
});
</script>
{% endblock %}