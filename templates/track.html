{% extends "base.html" %}

{% block content %}
<div class="container mt-4">
    <div class="main-card">
        <div class="d-flex justify-content-between align-items-center mb-3">
            <h2>{{ track_name }} Sessions</h2>
            <a href="{{ url_for('download', track_name=track_name) }}" class="btn btn-primary">
                Download CSV
            </a>
        </div>

        <!-- Chart Section -->
        <div class="mt-3">
            <div class="d-flex flex-wrap justify-content-between align-items-center gap-2">
                <div>
                    <label for="timeFilter" class="form-label me-2">Lap View:</label>
                    <select id="timeFilter" class="form-select form-select-sm d-inline w-auto">
                        <option value="improvement">Personal Bests Only</option>
                        <option value="all" selected>Every Race</option>
                        <option value="monthly">Fastest Race Each Month</option>
                        <option value="weekly">Fastest Race Each Week</option>
                        <option value="daily">Fastest Race Each Day</option>
                    </select>
                </div>
                <div>
                    <label for="rangeFilter" class="form-label me-2">Time Range:</label>
                    <select id="rangeFilter" class="form-select form-select-sm d-inline w-auto">
                        <option value="all" selected>All Time</option>
                        <option value="this_week">This Week</option>
                        <option value="this_month">This Month</option>
                        <option value="this_year">This Year</option>
                        <option value="custom">Custom Range</option>
                    </select>
                </div>
                <div id="customRangeInputs" style="display:none;">
                    <label for="fromDate" class="form-label me-1">From:</label>
                    <input type="date" id="fromDate" class="form-control form-control-sm d-inline w-auto me-2">
                    <label for="toDate" class="form-label me-1">To:</label>
                    <input type="date" id="toDate" class="form-control form-control-sm d-inline w-auto">
                </div>
                <button id="resetZoom" class="btn btn-outline-secondary btn-sm">Reset Zoom</button>
            </div>
            <div class="table-container-ios" style="background-color: #fff; padding: 10px; border-radius: 8px;">
                <canvas id="progressChart" height="400" style="touch-action: none;"></canvas>
            </div>
        </div>

        <!-- Session Table Section --> 
        <div class="table-responsive mt-4">
            <table id="lapsTable" class="table table-striped">
                <thead>
                    <tr>
                        <th onclick="sortTable(0)"><u>Date</u> <span class="sort-icons">⇅</span></th>
                        <th onclick="sortTable(1)"><u>Total Laps</u> <span class="sort-icons">⇅</span></th>
                        <th onclick="sortTable(2)"><u>Best Lap</u> <span class="sort-icons">⇅</span></th>
                        <th onclick="sortTable(3)"><u>Avg Lap</u> <span class="sort-icons">⇅</span></th>
                        <th onclick="sortTable(4)"><u>Fastest Lap #</u> <span class="sort-icons">⇅</span></th>
                        {% for i in range(1, 17) %}
                        <th onclick="sortTable({{ i + 4 }})"><u>Lap {{ i }}</u> <span class="sort-icons">⇅</span></th>
                        {% endfor %}
                    </tr>
                </thead>
                <tbody>
                    {% for s in sessions %}
                    <tr>
                        <td data-sort="{{ s.date }}">{{ s.date }}</td>
                        <td>{{ s.total_laps }}</td>
                        <td>{{ "%.3f"|format(s.best_lap|float) }}</td>
                        <td>{{ "%.3f"|format(s.avg_lap|float) }}</td>
                        <td>{{ s.fastest_lap_num }}</td>
                        {% for lap in s.laps %}
                        <td>{{ lap }}</td>
                        {% endfor %}
                        {% for i in range(16 - s.laps|length) %}
                        <td></td>
                        {% endfor %}
                    </tr>
                    {% endfor %}
                </tbody>
            </table>
        </div>
    </div>
</div>

<style>
.table-container-ios {
    overflow-x: auto;
    -webkit-overflow-scrolling: touch;
    width: 100%;
    border-radius: 8px;
    margin-bottom: 1rem;
}

.table-container-ios canvas {
    min-width: 600px;
}

#progressChart {
    touch-action: none;
}
</style>

<script>
document.addEventListener("DOMContentLoaded", function () {
    const ctx = document.getElementById('progressChart');
    if (!ctx) return;

    const labels = {{ chart_data.dates | tojson }};
    const data = {{ chart_data.best_laps | tojson }};
    let filteredLabels = labels.slice();
    let filteredData = data.slice();

    const improvementLabels = [];
    const improvementData = [];
    let bestSoFar = Infinity;
    for (let i = 0; i < labels.length; i++) {
        const lap = data[i];
        if (lap < bestSoFar) {
            bestSoFar = lap;
            improvementLabels.push(labels[i]);
            improvementData.push(lap);
        }
    }

    window.chart = new Chart(ctx, {
        type: 'line',
        data: {
            labels: labels,
            datasets: [{
                label: 'Best Lap Time (s)',
                data: data,
                borderColor: 'rgb(75, 192, 192)',
                tension: 0.1,
                pointBackgroundColor: 'rgb(75, 192, 192)',
                fill: false
            }]
        },
        options: {
            responsive: true,
            interaction: {
                mode: 'nearest',
                axis: 'x',
                intersect: false
            },
            plugins: {
                tooltip: { enabled: true },
                legend: { labels: { color: '#000' } },
                zoom: {
                    pan: { enabled: true, mode: 'x' },
                    zoom: {
                        wheel: { enabled: true },
                        pinch: { enabled: true },
                        mode: 'x'
                    }
                }
            },
            scales: {
                y: {
                    reverse: true,
                    title: { display: true, text: 'Seconds' },
                    ticks: { color: '#000', stepSize: 0.25, maxTicksLimit: 15 }
                },
                x: {
                    title: { display: true, text: 'Date' },
                    ticks: { color: '#000' }
                }
            }
        }
    });

    function getWeek(dateStr) {
        const [y, m, d] = dateStr.split('-').map(Number);
        const dt = new Date(Date.UTC(y, m - 1, d));
        dt.setUTCDate(dt.getUTCDate() + 4 - (dt.getUTCDay() || 7));
        const yearStart = new Date(Date.UTC(dt.getUTCFullYear(), 0, 1));
        return Math.ceil((((dt - yearStart) / 86400000) + 1) / 7);
    }

    function filterByTimeRange(range) {
        const now = new Date();
        let fromDate = null;

        if (range === 'this_month') {
            fromDate = new Date(now.getFullYear(), now.getMonth(), 1);
        } else if (range === 'this_week') {
            const day = now.getDay() || 7;
            fromDate = new Date(now);
            fromDate.setDate(now.getDate() - day + 1);
        } else if (range === 'this_year') {
            fromDate = new Date(now.getFullYear(), 0, 1);
        } else if (range === 'custom') {
            const from = document.getElementById('fromDate').value;
            const to = document.getElementById('toDate').value;
            if (from && to) {
                fromDate = new Date(from);
                const toDate = new Date(to);
                return labels.reduce((acc, dateStr, i) => {
                    const d = new Date(dateStr);
                    if (d >= fromDate && d <= toDate) {
                        acc.labels.push(dateStr);
                        acc.data.push(data[i]);
                    }
                    return acc;
                }, { labels: [], data: [] });
            } else {
                return { labels: [], data: [] };
            }
        }

        return labels.reduce((acc, dateStr, i) => {
            const d = new Date(dateStr);
            if (!fromDate || d >= fromDate) {
                acc.labels.push(dateStr);
                acc.data.push(data[i]);
            }
            return acc;
        }, { labels: [], data: [] });
    }

    function updateChart() {
        chart.resetZoom();
        const viewMode = document.getElementById('timeFilter').value;
        const timeRange = document.getElementById('rangeFilter').value;
        const result = filterByTimeRange(timeRange);

        filteredLabels = result.labels;
        filteredData = result.data;

        if (viewMode === 'improvement') {
            let impLabels = [];
            let impData = [];
            let best = Infinity;
            for (let i = 0; i < filteredLabels.length; i++) {
                const lap = filteredData[i];
                if (lap < best) {
                    best = lap;
                    impLabels.push(filteredLabels[i]);
                    impData.push(lap);
                }
            }
            chart.data.labels = impLabels;
            chart.data.datasets[0].data = impData;
        } else if (["daily", "weekly", "monthly"].includes(viewMode)) {
            let grouped = {};
            for (let i = 0; i < filteredLabels.length; i++) {
                let key = filteredLabels[i];
                if (viewMode === 'monthly') key = key.slice(0, 7);
                else if (viewMode === 'weekly') key = key.slice(0, 4) + '-W' + getWeek(key);
                if (!(key in grouped) || grouped[key] > filteredData[i]) {
                    grouped[key] = filteredData[i];
                }
            }
            chart.data.labels = Object.keys(grouped);
            chart.data.datasets[0].data = Object.values(grouped);
        } else {
            chart.data.labels = filteredLabels;
            chart.data.datasets[0].data = filteredData;
        }
        chart.update();
    }

    document.getElementById('timeFilter').addEventListener('change', updateChart);
    document.getElementById('rangeFilter').addEventListener('change', function () {
        const selected = this.value;
        document.getElementById('customRangeInputs').style.display = (selected === 'custom') ? 'block' : 'none';
        updateChart();
    });
    document.getElementById('fromDate').addEventListener('change', updateChart);
    document.getElementById('toDate').addEventListener('change', updateChart);
    document.getElementById('resetZoom').addEventListener('click', () => {
        chart.resetZoom();
    });
    updateChart();

    let sortDirections = [];
    window.sortTable = function (colIndex) {
        const table = document.getElementById("lapsTable");
        const tbody = table.tBodies[0];
        const rows = Array.from(tbody.rows);
        sortDirections[colIndex] = !sortDirections[colIndex];
        const dir = sortDirections[colIndex] ? 1 : -1;

        rows.sort((a, b) => {
            let A = a.cells[colIndex]?.innerText.trim() || "";
            let B = b.cells[colIndex]?.innerText.trim() || "";
            if (colIndex === 0) {
                const dateA = new Date(A);
                const dateB = new Date(B);
                return (dateA - dateB) * dir;
            }
            let nA = parseFloat(A), nB = parseFloat(B);
            if (!isNaN(nA) && !isNaN(nB)) return (nA - nB) * dir;
            return A.localeCompare(B) * dir;
        });
        rows.forEach(r => tbody.appendChild(r));
    };
});
</script>
{% endblock %}